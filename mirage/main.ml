(* Generated by ./config.exe configure -t unix (2021-07-20 12:18:48-00:00). *)

open Lwt.Infix
let return = Lwt.return
let run t = OS.Main.run t ; exit
0

let _ = Printexc.record_backtrace true

module Git_mirage_tcp1 = Git_mirage_tcp.Make(Tcpip_stack_socket.V4V6)

module Mirage_crypto_rng_mirage1 = Mirage_crypto_rng_mirage.Make(OS.Time)
  (Mclock)

module Git_mirage_ssh1 = Git_mirage_ssh.Make(Tcpip_stack_socket.V4V6)
  (Git_mirage_tcp1)(Mclock)

module Git_mirage_dns1 = Git_mirage_dns.Make(Mirage_crypto_rng_mirage1)
  (Mclock)(OS.Time)(Tcpip_stack_socket.V4V6)(Git_mirage_tcp1)

module Mimic1 = Mimic.Merge(Git_mirage_ssh1)(Git_mirage_dns1)

module Unikernel1 = Unikernel.Make(Mirage_crypto_rng_mirage1)(OS.Time)
  (Mclock)(Pclock)(Tcpip_stack_socket.V4V6)(Mimic1)

module Mirage_logs1 = Mirage_logs.Make(Pclock)

let tcpv4v6_socket11 = lazy (
  Tcpv4v6_socket.connect ~ipv4_only:(Key_gen.ipv4_only ()) ~ipv6_only:(Key_gen.ipv6_only ()) (Key_gen.ipv4 ()) (Key_gen.ipv6 ())
  )

let udpv4v6_socket11 = lazy (
  Udpv4v6_socket.connect ~ipv4_only:(Key_gen.ipv4_only ()) ~ipv6_only:(Key_gen.ipv6_only ()) (Key_gen.ipv4 ()) (Key_gen.ipv6 ())
  )

let stackv4v6_socket1 = lazy (
  let __udpv4v6_socket11 = Lazy.force udpv4v6_socket11 in
  let __tcpv4v6_socket11 = Lazy.force tcpv4v6_socket11 in
  __udpv4v6_socket11 >>= fun _udpv4v6_socket11 ->
  __tcpv4v6_socket11 >>= fun _tcpv4v6_socket11 ->
  Tcpip_stack_socket.V4V6.connect _udpv4v6_socket11 _tcpv4v6_socket11
  )

let time1 = lazy (
  return ()
  )

let mclock1 = lazy (
  return ()
  )

let tcp_ctx1 = lazy (
  let __stackv4v6_socket1 = Lazy.force stackv4v6_socket1 in
  __stackv4v6_socket1 >>= fun _stackv4v6_socket1 ->
  Lwt.return (Git_mirage_tcp1.with_stack _stackv4v6_socket1 Git_mirage_tcp1.ctx)
  )

let random1 = lazy (
  let __time1 = Lazy.force time1 in
  let __mclock1 = Lazy.force mclock1 in
  __time1 >>= fun _time1 ->
  __mclock1 >>= fun _mclock1 ->
  Mirage_crypto_rng_mirage1.initialize (module Mirage_crypto_rng.Fortuna)
  )

let ssh_rsa_ctx1 = lazy (
  let __stackv4v6_socket1 = Lazy.force stackv4v6_socket1 in
  let __tcp_ctx1 = Lazy.force tcp_ctx1 in
  let __mclock1 = Lazy.force mclock1 in
  __stackv4v6_socket1 >>= fun _stackv4v6_socket1 ->
  __tcp_ctx1 >>= fun _tcp_ctx1 ->
  __mclock1 >>= fun _mclock1 ->
  let ssh_ctx00 = Mimic.merge _tcp_ctx1 Git_mirage_ssh1.ctx in
                      let ssh_ctx01 = Option.fold ~none:ssh_ctx00 ~some:(fun v -> Git_mirage_ssh1.with_rsa_key v ssh_ctx00) (Key_gen.ssh_seed ()) in
                      let ssh_ctx02 = Option.fold ~none:ssh_ctx01 ~some:(fun v -> Git_mirage_ssh1.with_authenticator v ssh_ctx01) (Key_gen.ssh_auth ()) in
                      Lwt.return ssh_ctx02
  )

let dns_ctx1 = lazy (
  let __random1 = Lazy.force random1 in
  let __mclock1 = Lazy.force mclock1 in
  let __time1 = Lazy.force time1 in
  let __stackv4v6_socket1 = Lazy.force stackv4v6_socket1 in
  let __tcp_ctx1 = Lazy.force tcp_ctx1 in
  __random1 >>= fun _random1 ->
  __mclock1 >>= fun _mclock1 ->
  __time1 >>= fun _time1 ->
  __stackv4v6_socket1 >>= fun _stackv4v6_socket1 ->
  __tcp_ctx1 >>= fun _tcp_ctx1 ->
  let dns_ctx00 = Mimic.merge _tcp_ctx1 Git_mirage_dns1.ctx in
                      let dns_ctx01 = Git_mirage_dns1.with_dns _stackv4v6_socket1 dns_ctx00 in
                      Lwt.return dns_ctx01
  )

let argv_unix1 = lazy (
  Bootvar.argv ()
  )

let pclock1 = lazy (
  return ()
  )

let merge_ctx101 = lazy (
  let __ssh_rsa_ctx1 = Lazy.force ssh_rsa_ctx1 in
  let __dns_ctx1 = Lazy.force dns_ctx1 in
  __ssh_rsa_ctx1 >>= fun _ssh_rsa_ctx1 ->
  __dns_ctx1 >>= fun _dns_ctx1 ->
  Lwt.return (Mimic.merge _ssh_rsa_ctx1 _dns_ctx1)
  )

let ocaml_gc_control1 = lazy (
  Lwt.return (
let open Gc in
  let ctrl = get () in
  set ({ ctrl with allocation_policy = (match (Key_gen.allocation_policy ()) with `Next_fit -> 0 | `First_fit -> 1 | `Best_fit -> 2);
  minor_heap_size = (match (Key_gen.minor_heap_size ()) with None -> ctrl.minor_heap_size | Some x -> x);
  major_heap_increment = (match (Key_gen.major_heap_increment ()) with None -> ctrl.major_heap_increment | Some x -> x);
  space_overhead = (match (Key_gen.space_overhead ()) with None -> ctrl.space_overhead | Some x -> x);
  max_overhead = (match (Key_gen.max_space_overhead ()) with None -> ctrl.max_overhead | Some x -> x);
  verbose = (match (Key_gen.gc_verbosity ()) with None -> ctrl.verbose | Some x -> x);
  window_size = (match (Key_gen.gc_window_size ()) with None -> ctrl.window_size | Some x -> x);
  custom_major_ratio = (match (Key_gen.custom_major_ratio ()) with None -> ctrl.custom_major_ratio | Some x -> x);
  custom_minor_ratio = (match (Key_gen.custom_minor_ratio ()) with None -> ctrl.custom_minor_ratio | Some x -> x);
  custom_minor_max_size = (match (Key_gen.custom_minor_max_size ()) with None -> ctrl.custom_minor_max_size | Some x -> x) })
)
  )

let ocaml_hashtable_randomize1 = lazy (
  Lwt.return (if (Key_gen.randomize_hashtables ()) then Hashtbl.randomize ())
  )

let ocaml_backtrace1 = lazy (
  Lwt.return (Printexc.record_backtrace (Key_gen.backtrace ()))
  )

let key1 = lazy (
  let __argv_unix1 = Lazy.force argv_unix1 in
  __argv_unix1 >>= fun _argv_unix1 ->
  return (Functoria_runtime.with_argv (List.map fst Key_gen.runtime_keys) "contruno" _argv_unix1)
  )

let f11 = lazy (
  let __random1 = Lazy.force random1 in
  let __time1 = Lazy.force time1 in
  let __mclock1 = Lazy.force mclock1 in
  let __pclock1 = Lazy.force pclock1 in
  let __stackv4v6_socket1 = Lazy.force stackv4v6_socket1 in
  let __merge_ctx101 = Lazy.force merge_ctx101 in
  __random1 >>= fun _random1 ->
  __time1 >>= fun _time1 ->
  __mclock1 >>= fun _mclock1 ->
  __pclock1 >>= fun _pclock1 ->
  __stackv4v6_socket1 >>= fun _stackv4v6_socket1 ->
  __merge_ctx101 >>= fun _merge_ctx101 ->
  Unikernel1.start _random1 _time1 _mclock1 _pclock1 _stackv4v6_socket1
_merge_ctx101
  )

let mirage_logs1 = lazy (
  let __pclock1 = Lazy.force pclock1 in
  __pclock1 >>= fun _pclock1 ->
  let ring_size = None in
  let reporter = Mirage_logs1.create ?ring_size () in
  Mirage_runtime.set_level ~default:Logs.Info (Key_gen.logs ());
  Mirage_logs1.set_reporter reporter;
  Lwt.return reporter
  )

let mirage1 = lazy (
  let __key1 = Lazy.force key1 in
  let __ocaml_backtrace1 = Lazy.force ocaml_backtrace1 in
  let __ocaml_hashtable_randomize1 = Lazy.force ocaml_hashtable_randomize1 in
  let __ocaml_gc_control1 = Lazy.force ocaml_gc_control1 in
  let __mirage_logs1 = Lazy.force mirage_logs1 in
  let __f11 = Lazy.force f11 in
  __key1 >>= fun _key1 ->
  __ocaml_backtrace1 >>= fun _ocaml_backtrace1 ->
  __ocaml_hashtable_randomize1 >>= fun _ocaml_hashtable_randomize1 ->
  __ocaml_gc_control1 >>= fun _ocaml_gc_control1 ->
  __mirage_logs1 >>= fun _mirage_logs1 ->
  __f11 >>= fun _f11 ->
  Lwt.return_unit
  )

let () =
  let t =
  Lazy.force key1 >>= fun _ ->
    Lazy.force ocaml_backtrace1 >>= fun _ ->
    Lazy.force ocaml_hashtable_randomize1 >>= fun _ ->
    Lazy.force ocaml_gc_control1 >>= fun _ ->
    Lazy.force mirage_logs1 >>= fun _ ->
    Lazy.force mirage1
  in run t

